import time, logging, serial, RPi.GPIO as GPIO
logging.basicConfig(); logging.getLogger("pymodbus").setLevel(logging.DEBUG)

DE_PIN, RE_PIN = 23, 24
GPIO.setmode(GPIO.BCM)
GPIO.setup(DE_PIN, GPIO.OUT, initial=GPIO.LOW)  # LOW = driver off
GPIO.setup(RE_PIN, GPIO.OUT, initial=GPIO.LOW)  # LOW = receiver on

def set_tx():
    GPIO.output(DE_PIN, GPIO.HIGH)  # driver on
    GPIO.output(RE_PIN, GPIO.HIGH)  # receiver off

def set_rx():
    GPIO.output(DE_PIN, GPIO.LOW)   # driver off
    GPIO.output(RE_PIN, GPIO.LOW)   # receiver on

# --- Find the real pySerial object used by pymodbus
ser = None
for path in ("socket", "_serial", "transport", "protocol"):
    ser = getattr(client, path, None)
    if ser is not None:
        break
if hasattr(ser, "serial"):  # sometimes nested
    ser = ser.serial

print("Underlying serial object:", type(ser))
assert ser and hasattr(ser, "write"), "Couldn't access pySerial handle"

# --- Wrap write so we toggle DE/RE around actual TX
orig_write = ser.write
TURNAROUND_S = 0.006   # try 6 ms at 9600 bps

def write_with_dir(data: bytes):
    print(f"[DIR] TX {len(data)} bytes; DE=1,/RE=1")
    set_tx()
    n = orig_write(data)
    ser.flush()             # wait until bytes are *physically* sent
    time.sleep(TURNAROUND_S) # let bus settle, then go to RX
    set_rx()
    print(f"[DIR] RX mode; DE=0,/RE=0 (wait for reply)")
    return n

ser.write = write_with_dir

# --- Sanity: force RX before any request
set_rx()
