from pymodbus.client import ModbusSerialClient as ModbusClient
from serial.rs485 import RS485Settings  # not used here, but ok to keep
import serial, time, logging, RPi.GPIO as GPIO

# ---- GPIO pins for direction control ----
DE_PIN = 23   # goes to SP3485 DE
RE_PIN = 24   # goes to SP3485 /RE (active low)

# ---- GPIO setup ----
GPIO.setmode(GPIO.BCM)
GPIO.setup(DE_PIN, GPIO.OUT, initial=GPIO.LOW)  # LOW = driver off (RX)
GPIO.setup(RE_PIN, GPIO.OUT, initial=GPIO.LOW)  # LOW = receiver on (RX)

def set_tx():
    # TX mode: driver enabled, receiver disabled
    GPIO.output(DE_PIN, GPIO.HIGH)
    GPIO.output(RE_PIN, GPIO.HIGH)

def set_rx():
    # RX mode: driver disabled, receiver enabled
    GPIO.output(DE_PIN, GPIO.LOW)
    GPIO.output(RE_PIN, GPIO.LOW)

# ---- Modbus client (onboard UART) ----
client = ModbusClient(
    method="rtu",
    port="/dev/ttyAMA0",          # or your serial port
    baudrate=9600,                # match your device
    parity=serial.PARITY_EVEN,    # many Modbus devices default to 8E1
    stopbits=serial.STOPBITS_ONE,
    bytesize=serial.EIGHTBITS,
    timeout=1.5,
)

if not client.connect():
    print("❌ Could not connect."); GPIO.cleanup(); raise SystemExit

# IMPORTANT: Do NOT use rs485_mode here since we’re manually controlling DE/RE
# Grab underlying pySerial handle (varies by pymodbus version)
ser = getattr(client, "socket", None) or getattr(client, "_serial", None)
if hasattr(ser, "serial"):  # some wrappers
    ser = ser.serial

# Wrap the serial write so we toggle TX just for the bytes being sent,
# then switch to RX before the reply arrives.
orig_write = ser.write

TURNAROUND_S = 0.0015  # ~1–2 char times at 9600 baud; tweak 1–3 ms if needed

def write_with_dir(data: bytes):
    set_tx()
    n = orig_write(data)
    ser.flush()                 # wait until all bytes leave the UART
    time.sleep(TURNAROUND_S)    # allow the transceiver/bus to settle
    set_rx()
    return n

ser.write = write_with_dir

# ---- your helpers (unchanged) ----
def read_input_register(addr, scale=1, unit=1):
    try:
        rr = client.read_input_registers(addr, 1, slave=unit)
        if rr.isError():
            print(f"⚠️ Read 0x04 @ 0x{addr:04X}: {rr}")
            return None
        return rr.registers[0] / scale
    except Exception as e:
        print(f"Error reading 0x{addr:04X}: {e}")
        return None

def read_holding_register(addr, scale=1, unit=1):
    try:
        rr = client.read_holding_registers(addr, 1, slave=unit)
        if rr.isError():
            print(f"⚠️ Read 0x03 @ 0x{addr:04X}: {rr}")
            return None
        return rr.registers[0] / scale
    except Exception as e:
        print(f"Error reading 0x{addr:04X}: {e}")
        return None

def write_coil(address, state, unit=1):
    try:
        rr = client.write_coil(address, state, slave=unit)
        if rr.isError():
            print(f"⚠️ Write coil 0x{address:04X} failed: {rr}")
        else:
            print(f"✅ Coil {'ON' if state else 'OFF'} @ 0x{address:04X}")
    except Exception as e:
        print(f"Error writing coil 0x{address:04X}: {e}")

# ---- example loop ----
try:
    UNIT = 1
    while True:
        # Try holding (0x03) if input (0x04) doesn’t respond; also try addr-1
        voltage = read_holding_register(0x0008, 1, UNIT) or read_holding_register(0x0007, 1, UNIT)
        current = read_holding_register(0x0009, 100, UNIT) or read_holding_register(0x0008, 100, UNIT)
        power   = read_holding_register(0x000B, 10, UNIT) or read_holding_register(0x000A, 10, UNIT)
        pf      = read_holding_register(0x000A, 1000, UNIT) or read_holding_register(0x0009, 1000, UNIT)

        if None not in (voltage, current, power, pf):
            print(f"V:{voltage:.1f}V  I:{current:.2f}A  P:{power:.1f}W  PF:{pf:.3f}")
        else:
            print("⚠️ one or more reads failed")

        write_coil(0x0001, True, UNIT);  time.sleep(2)
        write_coil(0x0001, False, UNIT); time.sleep(2)
except KeyboardInterrupt:
    pass
finally:
    try:
        set_rx()
        client.close()
    finally:
        GPIO.cleanup()
